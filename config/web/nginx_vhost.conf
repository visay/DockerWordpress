server {
	listen      80;
	# TODO: Maybe we can just use $hostname instead
	server_name DOCKER_WORDPRESS_SERVERNAME;

	charset utf-8;

	root  /var/www/;
	index index.html index.php;

	# Enable gzip compression
	gzip  on;

	# Set the response header Vary: Accept-Encoding.
	# Some proxies have a bug in that they serve compressed content to browsers that don't support it.
	# By setting the Vary: Accept-Encoding header, you instruct proxies to store both a compressed and
	# uncompressed version of the content.
	gzip_vary on;

	# Enables or disables gzipping of responses for proxied requests depending on the request and response.
	gzip_proxied any;

	# This tells nginx what file types to compress (text/html is always compressed)
	gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript image/svg+xml;

	# Add mime-type for compressed js files.
	location ~ \.js\.gzip {
		types {
			text/javascript gzip;
		}
	}

	# Add mime-type for compressed css files.
	location ~ \.css\.gzip {
		types {
			text/css css;
		}
	}

	# Enable long browser caching for assets. This affects Frontend and Backend and increases performance.
	location ~* \.(js|css|png|jpg|jpeg|gif|ico|woff|ttf|svg|eot)$ {
		# etag is supported on nginx >= 1.3.3
		etag    on;
		expires 1y;
	}

	# Block access to hidden" directories or files.
	location ~ /\. {
		deny          all;
		access_log    off;
		log_not_found off;
	}

	# No need to log access to robots and favicon
	location = /favicon.ico {
		log_not_found off;
		access_log    off;
	}

	location = /robots.txt {
		allow         all;
		log_not_found off;
		access_log    off;
	}

	# Deny all attempts to access hidden files such as .htaccess, .htpasswd, .DS_Store (Mac).
	# Keep logging the requests to parse later (or to pass to firewall utilities such as fail2ban)
	location ~ /\. {
		deny all;
	}

	# Deny access to any files with a .php extension in the uploads directory
	# Works in sub-directory installs and also in multisite network
	# Keep logging the requests to parse later (or to pass to firewall utilities such as fail2ban)
	location ~* /(?:uploads|files)/.*\.php$ {
		deny all;
	}

	# Block access files accidentally left on the server.
	location (\.(bak|config|sql(\.zip|\.gz|\.bz2)?|ini|log|sh|inc|swp|t3d)|~)$ {
		deny          all;
		access_log    off;
		log_not_found off;
	}

	# Main URL rewriting
	location / {
		try_files $uri $uri/ /index.php$is_args$args;
	}

	# Add trailing slash to */wp-admin requests.
	rewrite /wp-admin$ $scheme://$host$uri/ permanent;

	# Pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
	location ~ \.php$ {
		include       /etc/nginx/fastcgi_params;
		try_files     $uri =404;
		fastcgi_pass  app:9000;
		fastcgi_index index.php;

		fastcgi_param SCRIPT_FILENAME   $document_root$fastcgi_script_name;
		fastcgi_param PATH_INFO         $fastcgi_path_info;
		fastcgi_param WORDPRESS_CONTEXT DOCKER_WORDPRESS_CONTEXT;
		fastcgi_param X-Forwarded-For   $proxy_add_x_forwarded_for;
		fastcgi_param X-Forwarded-Port  $proxy_port;
		fastcgi_param REMOTE_ADDR       $remote_addr;
		fastcgi_param REMOTE_PORT       $remote_port;
		fastcgi_param SERVER_ADDR       $server_addr;
		fastcgi_param SERVER_NAME       $http_host;

		fastcgi_intercept_errors        on;
		fastcgi_split_path_info         ^(.+?\.php)(/.*)$;
		if (!-f $document_root$fastcgi_script_name) {
			return 404;
		}
		fastcgi_read_timeout            600;
		fastcgi_buffer_size             128k;
		fastcgi_buffers                 256 16k;
		fastcgi_busy_buffers_size       256k;
		fastcgi_temp_file_write_size    256k;
	}
}
